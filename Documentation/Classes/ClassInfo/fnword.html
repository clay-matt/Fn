<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <meta name="Author" content="Matt Clay">

<link rel="stylesheet" type="text/css" href="../../style.css" />

<title>Free Group Calculator: FnWord</title>

</head>

<body>

<ul class="list-nav">

  <li><a href="../../index.html">Home</a></li>

  <li><a href="../../Functions/index.html">Functions</a></li>

  <li><a href="../../Tutorial/index.html">Tutorial</a></li>

  <li><a class="thispage" href="../index.html">Classes</a></li>

  <li><a href="../../Download/index.html">Download</a></li>

</ul>

<br>
<br>
<br>
<hr>

<img class="icon" src="../../Images/icon.png" alt="Fn" />

<p class="pagetitle">FnWord</p>

<p class="paragraph"> Inherits <a class="class"
href="http://doc.qt.nokia.com/4.7/qstring.html">QString</a>.  FnWord
is an element of the free group.  </p>

<p class="header">#include "FnWord.h"</p>

<p class="subsectionheader">Public Members</p>

<table class="classmembers">

  <tr>
    <td class="type"></td>
    <td><a class="membername" href="#FnWord">FnWord</a> ( )</td>
  </tr>

  <tr>
    <td class="type"></td>
    <td><a class="membername" href="#FnWord-qstring">FnWord</a> ( <span
    class="type">const QString</span> &
      <span class="input">other</span> )</td>
  </tr>

    <tr>
    <td class="type"></td>
    <td><a class="membername" href="#FnWord-qchar">FnWord</a> ( <span
    class="type">const QChar</span>
      <span class="input">a</span> )</td>
  </tr>

  <tr>
    <td class="type">QList&lt;int&gt; </td>
    <td><a class="membername" href="#abelianization">abelianization </a>
    ( <span class="type">const Basis</span> & <span class="input">basis</span>
      = <a class="code" href="basis.html#BASIS-CONST">BASIS</a> ) <span
    class="type">const</span></td>
  </tr>

  <tr>
    <td class="type">bool</td>
    <td><a class="membername" href="#checkbasis">checkBasis</a> (
      <span class="type">const
  Basis</span> & <span class="input">basis</span> = <a
      class="code" href="basis.html#BASIS-CONST">BASIS</a> )
    <span class="type">const</span></td>
  </tr>
  
  <tr>
    <td class="type">FnWord</td>
    <td><a class="membername" href="#cyclicword">cyclicWord</a> ( )
    <span class="type">const</span></td>
  </tr>

  <tr>
    <td class="type">FnWord</td>
    <td><a class="membername" href="#exp">exp</a> (<span
    class="type">int</span> <span class="input">n</span> )
    <span class="type">const</span></td>
  </tr>

  <tr>
    <td class="type">FnWord</td>
    <td><a class="membername" href="#inverse">inverse</a> ( )
    <span class="type">const</span></td>
  </tr>

  <tr>
    <td class="type">bool</td>
    <td><a class="membername" href="#isseparable">isSeparable</a> (
      <span class="type">const
  Basis</span> & <span class="input">basis</span> = <a
      class="code" href="basis.html#BASIS-CONST">BASIS</a> )
    <span class="type">const</span></td>
  </tr>

  <tr>
    <td class="type">bool</td>
    <td><a class="membername" href="#istrivial">isTrivial</a> ( )
    <span class="type">const</span></td>
  </tr>

  <tr>
    <td class="type">void</td>
    <td><a class="membername" href="#tighten">tighten</a> ( ) </td>
  </tr>


  <tr>
    <td class="type">QList&lt;int&gt; </td>
    <td><a class="membername" href="#twostepnilpotent">twoStepNilpotentNormalForm </a>
    ( <span class="type">const Basis</span> & <span class="input">basis</span>
      = <a class="code" href="basis.html#BASIS-CONST">BASIS</a> ) <span
    class="type">const</span></td>
  </tr>
  
  <tr>
    <td class="type">FnGraph</td>
    <td><a class="membername" href="#whiteheadgraph">whiteheadGraph</a> (
      <span class="type">const </span> <span class = "type"> Basis </span>
      & <span class = "input">basis</span> = <a class ="code" href
    ="basis.html#BASIS-CONST">BASIS</a>)<span class="type"> const
    </span></td>
  </tr>

  <tr>
    <td class="type">bool</td>
    <td><a class="membername" href="#operator!">operator ! </a>
    ( ) <span class="type">const</span></td>
  </tr>

  <tr>
    <td class="type">FnWord &</td>
    <td><a class="membername" href="#operator=qchar">operator = </a>
    ( <span class="type">const QChar</span> <span
    class="input">a</span> )</td>
  </tr>

  <tr>
    <td class="type">FnWord &</td>
    <td><a class="membername" href="#operator*=fnword">operator *= </a>
    ( <span class="type">const FnWord</span> & <span
    class="input">u</span> )</td>
  </tr>

    <tr>
    <td class="type">FnWord &</td>
    <td><a class="membername" href="#operator*=qchar">operator *= </a>
    ( <span class="type">const QChar</span> <span
    class="input">a</span> )</td>
  </tr>

</table>

<p class="subsectionheader">Related Non-Members</p>

<table class="classmembers">

  <tr>
    <td class="type">FnWord</td>
    <td><a class="membername" href="#operator*fnword">operator *</a>
    ( <span class="type">const FnWord</span> & <span
    class="input">u</span>, <span class="type">const FnWord</span> & <span
    class="input">v</span> ) </td>
  </tr>

  <tr>
    <td class="type">FnWord</td>
    <td><a class="membername" href="#operator*qcharfnword">operator *</a>
    ( <span class="type">const QChar</span> <span
    class="input">a</span>, <span class="type">const FnWord</span> & <span
    class="input">v</span> ) </td>
  </tr>

  <tr>
    <td class="type">FnWord</td>
    <td><a class="membername" href="#operator*fnwordqchar">operator *</a>
    ( <span class="type">const FnWord</span> & <span
    class="input">u</span>, <span class="type">const QChar</span> <span
    class="input">a</span> ) </td>
  </tr>

    <tr>
    <td class="type">FnWord</td>
    <td><a class="membername" href="#operator^fnword">operator ^</a>
    ( <span class="type">const FnWord</span> & <span
    class="input">u</span>, <span class="type">const FnWord</span> & <span
    class="input">v</span> ) </td>
  </tr>

  <tr>
    <td class="type">FnWord</td>
    <td><a class="membername" href="#operator^fnwordqchar">operator ^</a>
    ( <span class="type">const FnWord</span> & <span
    class="input">u</span>, <span class="type">const QChar</span> <span
    class="input">a</span> ) </td>
  </tr>

  <tr>
    <td class="type">FnWord</td>
    <td><a class="membername"
    href="#conjugacyproblem">conjugacyProblem</a> ( <span
    class="type">const FnWord</span> & <span class="input">u</span>,
    <span class="type">const FnWord</span> & <span
    class="input">v</span> )</td>
  </tr>

 <tr>
    <td class="type">bool</td>
    <td><a class="membername"
    href="#isseparable-non">isSeparable</a> ( <span
    class="type">QList&lt;FnWord&gt; </span> <span class="input">words</span>,
      <span class="type">const</span>
    <span class="type"> Basis</span> & <span
    class="input">basis</span> )</td>
  </tr>

   <tr>
    <td class="type">FnGraph</td>
    <td><a class="membername"
    href="#whiteheadgraph-non">whiteheadGraph</a> ( <span
    class="type">QList&lt;FnWord&gt; </span> words, <span class="type">const</span>
    <span class="type"> Basis</span> & <span
    class="input">basis</span> )</td>
  </tr>

 <tr>
    <td class="type">QList&lt;FnWord&gt;</td>
    <td><a class="membername"
    href="#wordsoflength">wordsOfLength</a> ( <span
    class="type">Basis </span> & <span class="input">basis</span>, <span class="type">int</span> <span class="input">len</span> )</td>
  </tr>
    
</table>

<p class="subsectionheader">Constants</p>

<table class="classmembers">

  <tr> <td class="type">FnWord</td> <td><a class="membername"
    href="#FAIL">FAIL</a> </td>
  </tr>

  <tr> <td class="type">FnWord</td> <td><a class="membername"
    href="#ID">ID</a> </td>
  </tr>

</table>

<p class="paragraph">  FnWord is an element of the free group.

<br /><br />

This class provides functionality for multiplying elements of a free
group and other basic group operations.  

</p>

<p class="subsectionheader">Member Definitions</p>

<p class="memberdescription"><a name="FnWord" />

<table class="memberheader">
  <tr><td><span class="membername">FnWord::FnWord</span> ( )</tr></td>
</table>

<br />

Default constructor for the class.  It constructs an empty QString.

</p>

<p class="memberdescription"><a name="FnWord-qstring" />

<table class="memberheader">
  <tr><td><span class="membername">FnWord::FnWord</span> ( <span
  class="type">const QString</span> & <span class="input">other</span>
  )</tr></td>
</table>

<br />

Constructs an FnWord using the word <span class="input">other</span>.

</p>

<p class="memberdescription"><a name="FnWord-qchar" />

<table class="memberheader">
  <tr><td><span class="membername">FnWord::FnWord</span> ( <span
  class="type">const QChar</span> <span class="input">a</span> )</tr></td>
</table>

<br />

Constructs an FnWord of length one with the element <span
class="input">a</span>.

</p>

<p class="memberdescription"><a name="abelianization" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">QList&lt;int&gt;</span>
      FnWord::abelianization</span> ( <span class="type">const
  Basis</span> & <span class="input">basis</span> = <a
      class="code" href="basis.html#BASIS-CONST">BASIS</a> ) <span
  class="type">const</span></td></tr> </table>

<br />

Returns the exponent sums of the FnWord as a word in the basis <span
class="input">basis</span>.  The exponent sum is the sum of the
positive occurances of a basis element <span class="input">x</span>
minus the negative occurances <span
class="input">x</span><sup>&minus;1</sup>.  For example, the
abelianization of the word <span
class="input">baab</span><sup>&minus;2</sup><span
class="input">a</span><sup>&minus;1</sup> in the basis
{<span class="input">a,&nbsp;b</span>} is [&nbsp;1&nbsp;&minus;1&nbsp;].
  
</p>

<p class="memberdescription"><a name="checkbasis" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">bool</span>
      FnWord::checkBasis</span> ( <span class="type">const
  Basis</span> & <span class="input">basis</span> = <a
      class="code" href="basis.html#BASIS-CONST">BASIS</a> ) <span
  class="type">const</span></td></tr> </table>

<br />

Checks whether or not the FnWord is a valid word in the basis <span
class="input">basis</span>.
  
</p>

<p class="memberdescription"><a name="cyclicword" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord</span>
      FnWord::cyclicWord</span> ( ) <span
  class="type">const</span></td></tr> </table>

<br />

Returns the FnWord obtained by removing all instances of
  initial-terminal <span class="input">x</span>&nbsp;-&nbsp;<span
  class="input">x</span><sup>&minus;1</sup> pairs.  To check if two
  words define the same cylic word (i.e., are conjugate) use <a
   class="code" href="#conjugacyProblem">FnWord::conjugacyProblem</a>.
  
</p>

<p class="memberdescription"><a name="exp" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord</span>
      FnWord::exp</span> ( <span class="type">int</span> <span
  class="input">n</span> ) <span
  class="type">const</span>
    </td>
  </tr>
</table>

<br />

Returns the <span class="input">n</span><sup>th</sup> power of the
  FnWord.
  
</p>

<p class="memberdescription"><a name="inverse" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord</span>
      FnWord::inverse </span> ( ) <span
  class="type">const</span>
    </td>
  </tr>
</table>

<br />

Returns the inverse the FnWord.
  
</p>

</p>

<p class="memberdescription"><a name="isseparable" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">bool</span>
      FnWord::isSeparable</span> ( <span class="type">const
  Basis</span> & <span class="input">basis</span> = <a
      class="code" href="basis.html#BASIS-CONST">BASIS</a> ) <span
  class="type">const</span></td></tr> </table>

<br />

Determines if the FnWord is contained in a proper free factor of the
free group with basis <span class="input">basis</span>.  See <a class="code"
 href="#isseparable-non">isSeparable</a>.
  
</p>

<p class="memberdescription"><a name="istrivial" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">bool</span> FnWord::isTrivial</span> ( )
    <span class="type">const</span>
    </td>
  </tr>
</table>

<br />

Determines if the FnWord represents <a href="#ID">ID</a>.

</p>
  
<p class="memberdescription"><a name="tighten" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord</span>
      FnWord::tighten</span> ( ) <span
  class="type"></span>
    </td>
  </tr>
</table>

<br />

Removes all instances of <span class="input">x</span>&nbsp;-&nbsp;<span
  class="input">x</span><sup>&minus;1</sup> pairs.

</p>

<p class="memberdescription"><a name="twostepnilpotent" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">QList&lt;int&gt;</span>
      FnWord::twoStepNilpotentNormalForm</span> ( <span class="type">const
  Basis</span> & <span class="input">basis</span> = <a
      class="code" href="basis.html#BASIS-CONST">BASIS</a> ) <span
  class="type">const</span></td></tr> </table>

<br />

Returns the two step nilpotent normal form of the FnWord as a word in
the basis <span class="input">basis</span>.  The first <span class="input">r</span>
entries are composed of the exponent sums of the basis elements where
<span class="input">r</span> is the rank <span class="input">basis</span> (see <span
class="type"><a class="code"
href="#abelianization">FnWord::abelianization</a></span>).  The
remaining <span class="input">r</span>(<span class="input">r</span>&nbsp;&minus;&nbsp;1)/2 are the
exponents of the commutators
[&nbsp;<span class="input">a<sub>i</sub>&nbsp;,&nbsp;a<sub>j</sub></span>&nbsp;]&nbsp;=&nbsp;<span class="input">a<sub>i</sub>&nbsp;a<sub>j</sub>&nbsp;a<sub>i</sub></span><sup>&minus;1</sup><span class="input">a<sub>j</sub></span><sup>&minus;1</sup>
where
1&nbsp;&leq;&nbsp;<span class="input">i</span>&nbsp;&lt;&nbsp;<span class="input">j</span>&nbsp;&leq;&nbsp;<span class="input">r</span>.
Words are converted to normal form using the relations:

  <table class="equations">
    <tr>
      <td class="eqleft"> <span class="input">ba</span> =</td>
      <td class="eqright">[ <span class="input">a , b</span> ]<sup>&minus;1</sup> <span class="input">ab</span></td>
    </tr>
    <tr>
      <td class="eqleft"> <span class="input">ba</span><sup>&minus;1</sup> =</td>
      <td class="eqright"><span class="input">a</span><sup>&minus;1</sup><span class="input">b</span>
	(<span class="input">b</span><sup>&minus;1</sup>[ <span class="input">a , b</span> ] <span class="input">b</span>)</td>
    </tr>
    <tr>
      <td class="eqleft"> <span class="input">b</span><sup>&minus;1</sup><span class="input">a</span> =</td>
      <td class="eqright"><span class="input">ab</span><sup>&minus;1</sup>
	(<span class="input">a</span><sup>&minus;1</sup>[ <span class="input">a , b</span> ] <span class="input">a</span>)</td>
    </tr>
    <tr>
      <td class="eqleft">  <span class="input">b</span><sup>&minus;1</sup><span class="input">a</span><sup>&minus;1</sup>
	=</td>
      <td class="eqright"><span class="input">a</span><sup>&minus;1</sup><span class="input">b</span><sup>&minus;1</sup>
	[ <span class="input">a , b</span> ]<sup>&minus;1</sup></td>
    </tr>    
    </table>

For more information about free nilpotent groups, see <a
        href="https://terrytao.wordpress.com/2009/12/21/the-free-nilpotent-group/">Terence
       Tao's Blog: What's New</a>.  Note, he defines commutators
       [&nbsp;<span class="input">g&nbsp;,&nbsp;h</span>&nbsp;]&nbsp;=&nbsp;<span class="input">g</span><sup>&minus;1</sup><span class="input">h</span><sup>&minus;1</sup><span class="input">gh</span>.
    
</p>


</p>

<p class="memberdescription"><a name="whiteheadGraph" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnGraph</span>
      FnWord::whiteheadGraph</span> ( <span class="type">const
  Basis</span> & <span class="input">basis</span> = <a
      class="code" href="basis.html#BASIS-CONST">BASIS</a> ) <span
  class="type">const</span></td></tr> </table>

<br />

Returns the Whitehead graph of the FnWord in the basis
<span class="input">basis</span>.  See <a class="code"
 href="#whiteheadgraph-non">whiteheadGraph</a>.
  
</p>

<p class="memberdescription"><a name="operator!" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">bool</span>
      FnWord::operator !</span> ( ) <span
  class="type">const</span>
    </td>
  </tr>
</table>

<br />

Returns true if the FnWord is equal to <a class="code"
href="#FAIL">FAIL</a>.  This can be used in conjunction with certain
functions that return FAIL as a fail state.  For example, <span
class="inlinecode">!conjugacyProblem(u,&nbsp;v)</span> is true if the
FnWords <span class="inlinecode">u</span> and <span
class="inlinecode">v</span> are not conjugate.

</p>

<p class="memberdescription"><a name="operator=qchar" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord &</span>
      FnWord::operator =</span> ( <span class="type">const QChar</span> <span
    class="input">a</span> )
    </td>
  </tr>
</table>

<br />

Sets the FnWord equal to the length one element <span
class="input">a</span>.

</p>

<p class="memberdescription"><a name="operator*=fnword" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord &</span>
      FnWord::operator *=</span> ( <span class="type">const
  FnWord</span> & <span
    class="input">u</span> )
    </td>
  </tr>
</table>

<br />

Multiplies the FnWord on the right by <span class="input">u</span>.

</p>

<p class="memberdescription"><a name="operator*=qchar" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord &</span>
      FnWord::operator *=</span> ( <span class="type">const QChar</span> <span
    class="input">a</span> )
    </td>
  </tr>
</table>

<br />

The overloads the function <a class="code"
href="#operator*=fnowrd">FnWord::operator&nbsp;*=&nbsp;(&nbsp;)</a>.

<br />
<br />

Multiplies the FnWord on the right by the length one element <span
class="input">a</span>.

</p>

<p class="subsectionheader">Non-Member Definitions</p>

<p class="memberdescription"><a name="operator*fnword" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord</span>
      operator *</span> ( <span class="type">const
  FnWord</span> & <span
    class="input">u</span>, <span class="type">const
  FnWord</span> & <span
    class="input">v</span> )
    </td>
  </tr>
</table>

<br />

Returns the product of the elements <span class="input">u</span> and
<span class="input">v</span>.

</p>

<p class="memberdescription"><a name="operator*qcharfnword" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord</span>
      operator *</span> ( <span class="type">const
  QChar</span> <span
    class="input">a</span>, <span class="type">const
  FnWord</span> & <span
    class="input">v</span> )
    </td>
  </tr>
</table>

<br />

The overloads the function <a class="code"
href="#operator*fnword">operator&nbsp;*&nbsp;(&nbsp;<span class="type">const
FnWord</span>&nbsp;&&nbsp;<span class="input">u</span>,&nbsp;<span class="type">const
FnWord</span>&nbsp;&&nbsp;<span class="input">v</span>&nbsp;)</a>.

<br />
<br />

Returns the product of the element <span class="input">u</span> and
the length one element <span class="input">a</span>.

</p>

<p class="memberdescription"><a name="operator*fnwordqchar" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord</span>
      operator *</span> ( <span class="type">const
  FnWord</span> & <span
    class="input">u</span>, <span class="type">const
  QChar</span> <span
    class="input">a</span> )
    </td>
  </tr>
</table>

<br />

The overloads the function <a class="code"
href="#operator*fnword">operator&nbsp;*&nbsp;(&nbsp;<span class="type">const
FnWord</span>&nbsp;&&nbsp;<span class="input">u</span>,&nbsp;<span class="type">const
FnWord</span>&nbsp;&&nbsp;<span class="input">v</span>&nbsp;)</a>.

<br />
<br />

Returns the product of the length one element <span
class="input">a</span> and the element <span class="input">v</span>.

</p>

<p class="memberdescription"><a name="operator^fnword" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord</span>
      operator ^</span> ( <span class="type">const
  FnWord</span> & <span
    class="input">u</span>, <span class="type">const
  FnWord</span> & <span
    class="input">v</span> )
    </td>
  </tr>
</table>

<br />

Returns the element <span class="input">vuv</span><sup>&minus;1</sup>.

</p>

<p class="memberdescription"><a name="operator^fnwordqchar" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord</span>
      operator ^</span> ( <span class="type">const
  FnWord</span> & <span
    class="input">u</span>, <span class="type">const
  QChar</span> <span
    class="input">a</span> )
    </td>
  </tr>
</table>

<br />

The overloads the function <a class="code"
href="#operator^fnword">operator&nbsp;^&nbsp;(&nbsp;<span class="type">const
FnWord</span>&nbsp;&&nbsp;<span class="input">u</span>, <span class="type">const
FnWord</span>&nbsp;&&nbsp;<span class="input">v</span>&nbsp;)</a>.

<br />
<br />

Returns the element <span class="input">aua</span><sup>&minus;1</sup>.

</p>

<p class="memberdescription"><a name="conjugacyproblem" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnWord</span>
      conjugacyProblem</span> ( <span class="type">const
  FnWord</span> & <span
    class="input">u</span>, <span class="type">const
  FnWord</span> & <span
    class="input">v</span> )
    </td>
  </tr>
</table>

<br />

Returns the element <span class="input">w</span> such that <span
class="input">u</span>&nbsp;=&nbsp;<span
class="input">wvw</span><sup>&minus;1</sup></span> if <span
class="input">w</span> exist.  If not, <a class="code"
href="#FAIL">FAIL</a> is returned.

</p>

<p class="memberdescription"><a name="isseparable-non" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">bool</span>
      FnWord::isSeparable</span> ( <span class="type">QList&lt;FnWord&gt;</span> <span class="input">words</span>, <span class="type">const
  Basis</span> & <span class="input">basis</span> ) </td></tr> </table>

<br />

Determines if the set <span class="input">words</span> is separable in
the free group with basis <span class="input">basis</span>.  A subset
of <span class="input">A</span> of the free group <span
class="input">F</span> is <span class="input">separable</span> when
there is a non-trivial free factorization <span
class="input">F</span>&nbsp;=&nbsp;<span
class="input">F<sub>1</sub>&nbsp;*&nbsp;F<sub>2</sub></span> such that
each element of <span class="input">A</span> is conjugate to an
element of either <span class="input">F<sub>1</sub></span> or <span
class="input">F<sub>2</sub></span>.  The algorithm to determine if the
set <span class="input">words</span> is separable is due to
J. R. Stallings.

<br />
<br />
  
Stallings, John R. "Whitehead graphs on
handlebodies." <b>Geometric group theory down under (Canberra,
1996)</b>, 317-330, de Gruyter, Berlin, 1999.

</p>

<p class="memberdescription"><a name="whiteheadgraph-non" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">FnGraph</span>
      whiteheadGraph</span> ( <span class="type">QList&lt;FnWord&gt;</span> <span class="input">words</span>, <span
    class="type">const</span> <span class="type">
  Basis</span> & <span
    class="input">basis</span> )
    </td>
  </tr>
</table>

<br />

Returns the Whitehead graph of the set <span
class="input">words</span> in the basis <span
class="input">basis</span>.  This is the graph with 2<span
class="input">r</span> vertices, where <span class="input">r</span> is
the rank of <span class="input">basis</span>, corresponding to the
elements <span class="input">a<sub>i</sub></span><sup>&pm;1</sup>.
For each subword <span class="input">uv</span> of one of the cyclic
words in the set <span class="input">words</span>, there is an edge
from <span class="input">u</span><sup>&plus;</sup> to <span
class="input">v</span><sup>&minus;</sup>.

</p>

<p class="memberdescription"><a name="wordsoflength" />

<table class="memberheader">
  <tr>
    <td><span class="membername"><span class="type">QList&lt;FnWord&gt;</span> wordsOfLength</span> ( <span class="type"> const Basis</span> &
      <span class="input">basis</span>, <span
    class="type">int</span> <span class="input">len</span> ) </td>
  </tr>
</table>

<br />

Returns the list of words of length <span class="input">len</span> in
the free group with basis <span class="input">basis</span>.

</p>

<p class="subsectionheader">Constants</p>

<p class="memberdescription"><a name="ID" />

<table class="memberheader">
  <tr>
    <td> <span
  class="type">const</span> <span class="membername">FnWord ID</span>
    </td>
  </tr>
</table>

<br />

This is a global constant represents the identity element in the free
  group.  It is constructed by FnWord ID(QString(<a class="code"
  href="fn.html#Fn_Identity">Fn_Identity</a>)).
  
</p>

<p class="memberdescription"><a name="FAIL" />

<table class="memberheader">
  <tr>
    <td> <span
  class="type">const</span> <span class="membername">FnWord FAIL</span>
    </td>
  </tr>
</table>

<br />

This is a global constant is used by <a class="code"
href="#conjugacyproblem">conjugacyProblem</a> and various functions in
<a class="code" href="fnmap.html">FnMap</a> as a way to pass a fail
state.
  
</p>

<p><a class="toptop" href="#">BACK TO TOP</a></p>

</body>
</html>

